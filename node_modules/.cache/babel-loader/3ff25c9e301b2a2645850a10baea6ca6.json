{"ast":null,"code":"'use strict';\n/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nconst fs = require('fs');\n\nconst FileWriter = require('./file-writer');\n\nconst XMLWriter = require('./xml-writer');\n\nconst tree = require('./tree');\n\nconst watermarks = require('./watermarks');\n\nconst SummarizerFactory = require('./summarizer-factory');\n\nfunction defaultSourceLookup(path) {\n  try {\n    return fs.readFileSync(path, 'utf8');\n  } catch (ex) {\n    throw new Error(`Unable to lookup source: ${path} (${ex.message})`);\n  }\n}\n\nfunction normalizeWatermarks() {\n  let specified = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  Object.entries(watermarks.getDefault()).forEach(_ref => {\n    let [k, value] = _ref;\n    const specValue = specified[k];\n\n    if (!Array.isArray(specValue) || specValue.length !== 2) {\n      specified[k] = value;\n    }\n  });\n  return specified;\n}\n/**\n * A reporting context that is passed to report implementations\n * @param {Object} [opts=null] opts options\n * @param {String} [opts.dir='coverage'] opts.dir the reporting directory\n * @param {Object} [opts.watermarks=null] opts.watermarks watermarks for\n *  statements, lines, branches and functions\n * @param {Function} [opts.sourceFinder=fsLookup] opts.sourceFinder a\n *  function that returns source code given a file path. Defaults to\n *  filesystem lookups based on path.\n * @constructor\n */\n\n\nclass Context {\n  constructor(opts) {\n    this.dir = opts.dir || 'coverage';\n    this.watermarks = normalizeWatermarks(opts.watermarks);\n    this.sourceFinder = opts.sourceFinder || defaultSourceLookup;\n    this._summarizerFactory = new SummarizerFactory(opts.coverageMap, opts.defaultSummarizer);\n    this.data = {};\n  }\n  /**\n   * returns a FileWriter implementation for reporting use. Also available\n   * as the `writer` property on the context.\n   * @returns {Writer}\n   */\n\n\n  getWriter() {\n    return this.writer;\n  }\n  /**\n   * returns the source code for the specified file path or throws if\n   * the source could not be found.\n   * @param {String} filePath the file path as found in a file coverage object\n   * @returns {String} the source code\n   */\n\n\n  getSource(filePath) {\n    return this.sourceFinder(filePath);\n  }\n  /**\n   * returns the coverage class given a coverage\n   * types and a percentage value.\n   * @param {String} type - the coverage type, one of `statements`, `functions`,\n   *  `branches`, or `lines`\n   * @param {Number} value - the percentage value\n   * @returns {String} one of `high`, `medium` or `low`\n   */\n\n\n  classForPercent(type, value) {\n    const watermarks = this.watermarks[type];\n\n    if (!watermarks) {\n      return 'unknown';\n    }\n\n    if (value < watermarks[0]) {\n      return 'low';\n    }\n\n    if (value >= watermarks[1]) {\n      return 'high';\n    }\n\n    return 'medium';\n  }\n  /**\n   * returns an XML writer for the supplied content writer\n   * @param {ContentWriter} contentWriter the content writer to which the returned XML writer\n   *  writes data\n   * @returns {XMLWriter}\n   */\n\n\n  getXMLWriter(contentWriter) {\n    return new XMLWriter(contentWriter);\n  }\n  /**\n   * returns a full visitor given a partial one.\n   * @param {Object} partialVisitor a partial visitor only having the functions of\n   *  interest to the caller. These functions are called with a scope that is the\n   *  supplied object.\n   * @returns {Visitor}\n   */\n\n\n  getVisitor(partialVisitor) {\n    return new tree.Visitor(partialVisitor);\n  }\n\n  getTree() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'defaultSummarizer';\n    return this._summarizerFactory[name];\n  }\n\n}\n\nObject.defineProperty(Context.prototype, 'writer', {\n  enumerable: true,\n\n  get() {\n    if (!this.data.writer) {\n      this.data.writer = new FileWriter(this.dir);\n    }\n\n    return this.data.writer;\n  }\n\n});\nmodule.exports = Context;","map":{"version":3,"sources":["/Users/mdraghi/Development/code/Phase-3/Phase-3-Project/dotify/node_modules/istanbul-lib-report/lib/context.js"],"names":["fs","require","FileWriter","XMLWriter","tree","watermarks","SummarizerFactory","defaultSourceLookup","path","readFileSync","ex","Error","message","normalizeWatermarks","specified","Object","entries","getDefault","forEach","k","value","specValue","Array","isArray","length","Context","constructor","opts","dir","sourceFinder","_summarizerFactory","coverageMap","defaultSummarizer","data","getWriter","writer","getSource","filePath","classForPercent","type","getXMLWriter","contentWriter","getVisitor","partialVisitor","Visitor","getTree","name","defineProperty","prototype","enumerable","get","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nconst fs = require('fs');\nconst FileWriter = require('./file-writer');\nconst XMLWriter = require('./xml-writer');\nconst tree = require('./tree');\nconst watermarks = require('./watermarks');\nconst SummarizerFactory = require('./summarizer-factory');\n\nfunction defaultSourceLookup(path) {\n    try {\n        return fs.readFileSync(path, 'utf8');\n    } catch (ex) {\n        throw new Error(`Unable to lookup source: ${path} (${ex.message})`);\n    }\n}\n\nfunction normalizeWatermarks(specified = {}) {\n    Object.entries(watermarks.getDefault()).forEach(([k, value]) => {\n        const specValue = specified[k];\n        if (!Array.isArray(specValue) || specValue.length !== 2) {\n            specified[k] = value;\n        }\n    });\n\n    return specified;\n}\n\n/**\n * A reporting context that is passed to report implementations\n * @param {Object} [opts=null] opts options\n * @param {String} [opts.dir='coverage'] opts.dir the reporting directory\n * @param {Object} [opts.watermarks=null] opts.watermarks watermarks for\n *  statements, lines, branches and functions\n * @param {Function} [opts.sourceFinder=fsLookup] opts.sourceFinder a\n *  function that returns source code given a file path. Defaults to\n *  filesystem lookups based on path.\n * @constructor\n */\nclass Context {\n    constructor(opts) {\n        this.dir = opts.dir || 'coverage';\n        this.watermarks = normalizeWatermarks(opts.watermarks);\n        this.sourceFinder = opts.sourceFinder || defaultSourceLookup;\n        this._summarizerFactory = new SummarizerFactory(\n            opts.coverageMap,\n            opts.defaultSummarizer\n        );\n        this.data = {};\n    }\n\n    /**\n     * returns a FileWriter implementation for reporting use. Also available\n     * as the `writer` property on the context.\n     * @returns {Writer}\n     */\n    getWriter() {\n        return this.writer;\n    }\n\n    /**\n     * returns the source code for the specified file path or throws if\n     * the source could not be found.\n     * @param {String} filePath the file path as found in a file coverage object\n     * @returns {String} the source code\n     */\n    getSource(filePath) {\n        return this.sourceFinder(filePath);\n    }\n\n    /**\n     * returns the coverage class given a coverage\n     * types and a percentage value.\n     * @param {String} type - the coverage type, one of `statements`, `functions`,\n     *  `branches`, or `lines`\n     * @param {Number} value - the percentage value\n     * @returns {String} one of `high`, `medium` or `low`\n     */\n    classForPercent(type, value) {\n        const watermarks = this.watermarks[type];\n        if (!watermarks) {\n            return 'unknown';\n        }\n        if (value < watermarks[0]) {\n            return 'low';\n        }\n        if (value >= watermarks[1]) {\n            return 'high';\n        }\n        return 'medium';\n    }\n\n    /**\n     * returns an XML writer for the supplied content writer\n     * @param {ContentWriter} contentWriter the content writer to which the returned XML writer\n     *  writes data\n     * @returns {XMLWriter}\n     */\n    getXMLWriter(contentWriter) {\n        return new XMLWriter(contentWriter);\n    }\n\n    /**\n     * returns a full visitor given a partial one.\n     * @param {Object} partialVisitor a partial visitor only having the functions of\n     *  interest to the caller. These functions are called with a scope that is the\n     *  supplied object.\n     * @returns {Visitor}\n     */\n    getVisitor(partialVisitor) {\n        return new tree.Visitor(partialVisitor);\n    }\n\n    getTree(name = 'defaultSummarizer') {\n        return this._summarizerFactory[name];\n    }\n}\n\nObject.defineProperty(Context.prototype, 'writer', {\n    enumerable: true,\n    get() {\n        if (!this.data.writer) {\n            this.data.writer = new FileWriter(this.dir);\n        }\n        return this.data.writer;\n    }\n});\n\nmodule.exports = Context;\n"]},"metadata":{},"sourceType":"script"}