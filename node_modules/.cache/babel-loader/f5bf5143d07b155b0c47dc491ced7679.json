{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst coverage = require('istanbul-lib-coverage');\n\nconst Path = require('./path');\n\nconst {\n  BaseNode,\n  BaseTree\n} = require('./tree');\n\nclass ReportNode extends BaseNode {\n  constructor(path, fileCoverage) {\n    super();\n    this.path = path;\n    this.parent = null;\n    this.fileCoverage = fileCoverage;\n    this.children = [];\n  }\n\n  static createRoot(children) {\n    const root = new ReportNode(new Path([]));\n    children.forEach(child => {\n      root.addChild(child);\n    });\n    return root;\n  }\n\n  addChild(child) {\n    child.parent = this;\n    this.children.push(child);\n  }\n\n  asRelative(p) {\n    if (p.substring(0, 1) === '/') {\n      return p.substring(1);\n    }\n\n    return p;\n  }\n\n  getQualifiedName() {\n    return this.asRelative(this.path.toString());\n  }\n\n  getRelativeName() {\n    const parent = this.getParent();\n    const myPath = this.path;\n    let relPath;\n    let i;\n    const parentPath = parent ? parent.path : new Path([]);\n\n    if (parentPath.ancestorOf(myPath)) {\n      relPath = new Path(myPath.elements());\n\n      for (i = 0; i < parentPath.length; i += 1) {\n        relPath.shift();\n      }\n\n      return this.asRelative(relPath.toString());\n    }\n\n    return this.asRelative(this.path.toString());\n  }\n\n  getParent() {\n    return this.parent;\n  }\n\n  getChildren() {\n    return this.children;\n  }\n\n  isSummary() {\n    return !this.fileCoverage;\n  }\n\n  getFileCoverage() {\n    return this.fileCoverage;\n  }\n\n  getCoverageSummary(filesOnly) {\n    const cacheProp = `c_${filesOnly ? 'files' : 'full'}`;\n    let summary;\n\n    if (Object.prototype.hasOwnProperty.call(this, cacheProp)) {\n      return this[cacheProp];\n    }\n\n    if (!this.isSummary()) {\n      summary = this.getFileCoverage().toSummary();\n    } else {\n      let count = 0;\n      summary = coverage.createCoverageSummary();\n      this.getChildren().forEach(child => {\n        if (filesOnly && child.isSummary()) {\n          return;\n        }\n\n        count += 1;\n        summary.merge(child.getCoverageSummary(filesOnly));\n      });\n\n      if (count === 0 && filesOnly) {\n        summary = null;\n      }\n    }\n\n    this[cacheProp] = summary;\n    return summary;\n  }\n\n}\n\nclass ReportTree extends BaseTree {\n  constructor(root, childPrefix) {\n    super(root);\n\n    const maybePrefix = node => {\n      if (childPrefix && !node.isRoot()) {\n        node.path.unshift(childPrefix);\n      }\n    };\n\n    this.visit({\n      onDetail: maybePrefix,\n\n      onSummary(node) {\n        maybePrefix(node);\n        node.children.sort((a, b) => {\n          const astr = a.path.toString();\n          const bstr = b.path.toString();\n          return astr < bstr ? -1 : astr > bstr ? 1 :\n          /* istanbul ignore next */\n          0;\n        });\n      }\n\n    });\n  }\n\n}\n\nfunction findCommonParent(paths) {\n  return paths.reduce((common, path) => common.commonPrefixPath(path), paths[0] || new Path([]));\n}\n\nfunction findOrCreateParent(parentPath, nodeMap) {\n  let created = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};\n  let parent = nodeMap[parentPath.toString()];\n\n  if (!parent) {\n    parent = new ReportNode(parentPath);\n    nodeMap[parentPath.toString()] = parent;\n    created(parentPath, parent);\n  }\n\n  return parent;\n}\n\nfunction toDirParents(list) {\n  const nodeMap = Object.create(null);\n  list.forEach(o => {\n    const parent = findOrCreateParent(o.path.parent(), nodeMap);\n    parent.addChild(new ReportNode(o.path, o.fileCoverage));\n  });\n  return Object.values(nodeMap);\n}\n\nfunction addAllPaths(topPaths, nodeMap, path, node) {\n  const parent = findOrCreateParent(path.parent(), nodeMap, (parentPath, parent) => {\n    if (parentPath.hasParent()) {\n      addAllPaths(topPaths, nodeMap, parentPath, parent);\n    } else {\n      topPaths.push(parent);\n    }\n  });\n  parent.addChild(node);\n}\n\nfunction foldIntoOneDir(node, parent) {\n  const {\n    children\n  } = node;\n\n  if (children.length === 1 && !children[0].fileCoverage) {\n    children[0].parent = parent;\n    return foldIntoOneDir(children[0], parent);\n  }\n\n  node.children = children.map(child => foldIntoOneDir(child, node));\n  return node;\n}\n\nfunction pkgSummaryPrefix(dirParents, commonParent) {\n  if (!dirParents.some(dp => dp.path.length === 0)) {\n    return;\n  }\n\n  if (commonParent.length === 0) {\n    return 'root';\n  }\n\n  return commonParent.name();\n}\n\nclass SummarizerFactory {\n  constructor(coverageMap) {\n    let defaultSummarizer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'pkg';\n    this._coverageMap = coverageMap;\n    this._defaultSummarizer = defaultSummarizer;\n    this._initialList = coverageMap.files().map(filePath => ({\n      filePath,\n      path: new Path(filePath),\n      fileCoverage: coverageMap.fileCoverageFor(filePath)\n    }));\n    this._commonParent = findCommonParent(this._initialList.map(o => o.path.parent()));\n\n    if (this._commonParent.length > 0) {\n      this._initialList.forEach(o => {\n        o.path.splice(0, this._commonParent.length);\n      });\n    }\n  }\n\n  get defaultSummarizer() {\n    return this[this._defaultSummarizer];\n  }\n\n  get flat() {\n    if (!this._flat) {\n      this._flat = new ReportTree(ReportNode.createRoot(this._initialList.map(node => new ReportNode(node.path, node.fileCoverage))));\n    }\n\n    return this._flat;\n  }\n\n  _createPkg() {\n    const dirParents = toDirParents(this._initialList);\n\n    if (dirParents.length === 1) {\n      return new ReportTree(dirParents[0]);\n    }\n\n    return new ReportTree(ReportNode.createRoot(dirParents), pkgSummaryPrefix(dirParents, this._commonParent));\n  }\n\n  get pkg() {\n    if (!this._pkg) {\n      this._pkg = this._createPkg();\n    }\n\n    return this._pkg;\n  }\n\n  _createNested() {\n    const nodeMap = Object.create(null);\n    const topPaths = [];\n\n    this._initialList.forEach(o => {\n      const node = new ReportNode(o.path, o.fileCoverage);\n      addAllPaths(topPaths, nodeMap, o.path, node);\n    });\n\n    const topNodes = topPaths.map(node => foldIntoOneDir(node));\n\n    if (topNodes.length === 1) {\n      return new ReportTree(topNodes[0]);\n    }\n\n    return new ReportTree(ReportNode.createRoot(topNodes));\n  }\n\n  get nested() {\n    if (!this._nested) {\n      this._nested = this._createNested();\n    }\n\n    return this._nested;\n  }\n\n}\n\nmodule.exports = SummarizerFactory;","map":{"version":3,"sources":["/Users/mdraghi/Development/code/Phase-3/Phase-3-Project/dotify/node_modules/istanbul-lib-report/lib/summarizer-factory.js"],"names":["coverage","require","Path","BaseNode","BaseTree","ReportNode","constructor","path","fileCoverage","parent","children","createRoot","root","forEach","child","addChild","push","asRelative","p","substring","getQualifiedName","toString","getRelativeName","getParent","myPath","relPath","i","parentPath","ancestorOf","elements","length","shift","getChildren","isSummary","getFileCoverage","getCoverageSummary","filesOnly","cacheProp","summary","Object","prototype","hasOwnProperty","call","toSummary","count","createCoverageSummary","merge","ReportTree","childPrefix","maybePrefix","node","isRoot","unshift","visit","onDetail","onSummary","sort","a","b","astr","bstr","findCommonParent","paths","reduce","common","commonPrefixPath","findOrCreateParent","nodeMap","created","toDirParents","list","create","o","values","addAllPaths","topPaths","hasParent","foldIntoOneDir","map","pkgSummaryPrefix","dirParents","commonParent","some","dp","name","SummarizerFactory","coverageMap","defaultSummarizer","_coverageMap","_defaultSummarizer","_initialList","files","filePath","fileCoverageFor","_commonParent","splice","flat","_flat","_createPkg","pkg","_pkg","_createNested","topNodes","nested","_nested","module","exports"],"mappings":"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","sourcesContent":["/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst coverage = require('istanbul-lib-coverage');\nconst Path = require('./path');\nconst { BaseNode, BaseTree } = require('./tree');\n\nclass ReportNode extends BaseNode {\n    constructor(path, fileCoverage) {\n        super();\n\n        this.path = path;\n        this.parent = null;\n        this.fileCoverage = fileCoverage;\n        this.children = [];\n    }\n\n    static createRoot(children) {\n        const root = new ReportNode(new Path([]));\n\n        children.forEach(child => {\n            root.addChild(child);\n        });\n\n        return root;\n    }\n\n    addChild(child) {\n        child.parent = this;\n        this.children.push(child);\n    }\n\n    asRelative(p) {\n        if (p.substring(0, 1) === '/') {\n            return p.substring(1);\n        }\n        return p;\n    }\n\n    getQualifiedName() {\n        return this.asRelative(this.path.toString());\n    }\n\n    getRelativeName() {\n        const parent = this.getParent();\n        const myPath = this.path;\n        let relPath;\n        let i;\n        const parentPath = parent ? parent.path : new Path([]);\n        if (parentPath.ancestorOf(myPath)) {\n            relPath = new Path(myPath.elements());\n            for (i = 0; i < parentPath.length; i += 1) {\n                relPath.shift();\n            }\n            return this.asRelative(relPath.toString());\n        }\n        return this.asRelative(this.path.toString());\n    }\n\n    getParent() {\n        return this.parent;\n    }\n\n    getChildren() {\n        return this.children;\n    }\n\n    isSummary() {\n        return !this.fileCoverage;\n    }\n\n    getFileCoverage() {\n        return this.fileCoverage;\n    }\n\n    getCoverageSummary(filesOnly) {\n        const cacheProp = `c_${filesOnly ? 'files' : 'full'}`;\n        let summary;\n\n        if (Object.prototype.hasOwnProperty.call(this, cacheProp)) {\n            return this[cacheProp];\n        }\n\n        if (!this.isSummary()) {\n            summary = this.getFileCoverage().toSummary();\n        } else {\n            let count = 0;\n            summary = coverage.createCoverageSummary();\n            this.getChildren().forEach(child => {\n                if (filesOnly && child.isSummary()) {\n                    return;\n                }\n                count += 1;\n                summary.merge(child.getCoverageSummary(filesOnly));\n            });\n            if (count === 0 && filesOnly) {\n                summary = null;\n            }\n        }\n        this[cacheProp] = summary;\n        return summary;\n    }\n}\n\nclass ReportTree extends BaseTree {\n    constructor(root, childPrefix) {\n        super(root);\n\n        const maybePrefix = node => {\n            if (childPrefix && !node.isRoot()) {\n                node.path.unshift(childPrefix);\n            }\n        };\n        this.visit({\n            onDetail: maybePrefix,\n            onSummary(node) {\n                maybePrefix(node);\n                node.children.sort((a, b) => {\n                    const astr = a.path.toString();\n                    const bstr = b.path.toString();\n                    return astr < bstr\n                        ? -1\n                        : astr > bstr\n                        ? 1\n                        : /* istanbul ignore next */ 0;\n                });\n            }\n        });\n    }\n}\n\nfunction findCommonParent(paths) {\n    return paths.reduce(\n        (common, path) => common.commonPrefixPath(path),\n        paths[0] || new Path([])\n    );\n}\n\nfunction findOrCreateParent(parentPath, nodeMap, created = () => {}) {\n    let parent = nodeMap[parentPath.toString()];\n\n    if (!parent) {\n        parent = new ReportNode(parentPath);\n        nodeMap[parentPath.toString()] = parent;\n        created(parentPath, parent);\n    }\n\n    return parent;\n}\n\nfunction toDirParents(list) {\n    const nodeMap = Object.create(null);\n    list.forEach(o => {\n        const parent = findOrCreateParent(o.path.parent(), nodeMap);\n        parent.addChild(new ReportNode(o.path, o.fileCoverage));\n    });\n\n    return Object.values(nodeMap);\n}\n\nfunction addAllPaths(topPaths, nodeMap, path, node) {\n    const parent = findOrCreateParent(\n        path.parent(),\n        nodeMap,\n        (parentPath, parent) => {\n            if (parentPath.hasParent()) {\n                addAllPaths(topPaths, nodeMap, parentPath, parent);\n            } else {\n                topPaths.push(parent);\n            }\n        }\n    );\n\n    parent.addChild(node);\n}\n\nfunction foldIntoOneDir(node, parent) {\n    const { children } = node;\n    if (children.length === 1 && !children[0].fileCoverage) {\n        children[0].parent = parent;\n        return foldIntoOneDir(children[0], parent);\n    }\n    node.children = children.map(child => foldIntoOneDir(child, node));\n    return node;\n}\n\nfunction pkgSummaryPrefix(dirParents, commonParent) {\n    if (!dirParents.some(dp => dp.path.length === 0)) {\n        return;\n    }\n\n    if (commonParent.length === 0) {\n        return 'root';\n    }\n\n    return commonParent.name();\n}\n\nclass SummarizerFactory {\n    constructor(coverageMap, defaultSummarizer = 'pkg') {\n        this._coverageMap = coverageMap;\n        this._defaultSummarizer = defaultSummarizer;\n        this._initialList = coverageMap.files().map(filePath => ({\n            filePath,\n            path: new Path(filePath),\n            fileCoverage: coverageMap.fileCoverageFor(filePath)\n        }));\n        this._commonParent = findCommonParent(\n            this._initialList.map(o => o.path.parent())\n        );\n        if (this._commonParent.length > 0) {\n            this._initialList.forEach(o => {\n                o.path.splice(0, this._commonParent.length);\n            });\n        }\n    }\n\n    get defaultSummarizer() {\n        return this[this._defaultSummarizer];\n    }\n\n    get flat() {\n        if (!this._flat) {\n            this._flat = new ReportTree(\n                ReportNode.createRoot(\n                    this._initialList.map(\n                        node => new ReportNode(node.path, node.fileCoverage)\n                    )\n                )\n            );\n        }\n\n        return this._flat;\n    }\n\n    _createPkg() {\n        const dirParents = toDirParents(this._initialList);\n        if (dirParents.length === 1) {\n            return new ReportTree(dirParents[0]);\n        }\n\n        return new ReportTree(\n            ReportNode.createRoot(dirParents),\n            pkgSummaryPrefix(dirParents, this._commonParent)\n        );\n    }\n\n    get pkg() {\n        if (!this._pkg) {\n            this._pkg = this._createPkg();\n        }\n\n        return this._pkg;\n    }\n\n    _createNested() {\n        const nodeMap = Object.create(null);\n        const topPaths = [];\n        this._initialList.forEach(o => {\n            const node = new ReportNode(o.path, o.fileCoverage);\n            addAllPaths(topPaths, nodeMap, o.path, node);\n        });\n\n        const topNodes = topPaths.map(node => foldIntoOneDir(node));\n        if (topNodes.length === 1) {\n            return new ReportTree(topNodes[0]);\n        }\n\n        return new ReportTree(ReportNode.createRoot(topNodes));\n    }\n\n    get nested() {\n        if (!this._nested) {\n            this._nested = this._createNested();\n        }\n\n        return this._nested;\n    }\n}\n\nmodule.exports = SummarizerFactory;\n"]},"metadata":{},"sourceType":"script"}