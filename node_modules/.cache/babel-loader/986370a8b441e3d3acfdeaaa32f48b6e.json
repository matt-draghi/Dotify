{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst path = require('path');\n\nlet parsePath = path.parse;\nlet SEP = path.sep;\nconst origParser = parsePath;\nconst origSep = SEP;\n\nfunction makeRelativeNormalizedPath(str, sep) {\n  const parsed = parsePath(str);\n  let root = parsed.root;\n  let dir;\n  let file = parsed.base;\n  let quoted;\n  let pos; // handle a weird windows case separately\n\n  if (sep === '\\\\') {\n    pos = root.indexOf(':\\\\');\n\n    if (pos >= 0) {\n      root = root.substring(0, pos + 2);\n    }\n  }\n\n  dir = parsed.dir.substring(root.length);\n\n  if (str === '') {\n    return [];\n  }\n\n  if (sep !== '/') {\n    quoted = new RegExp(sep.replace(/\\W/g, '\\\\$&'), 'g');\n    dir = dir.replace(quoted, '/');\n    file = file.replace(quoted, '/'); // excessively paranoid?\n  }\n\n  if (dir !== '') {\n    dir = `${dir}/${file}`;\n  } else {\n    dir = file;\n  }\n\n  if (dir.substring(0, 1) === '/') {\n    dir = dir.substring(1);\n  }\n\n  dir = dir.split(/\\/+/);\n  return dir;\n}\n\nclass Path {\n  constructor(strOrArray) {\n    if (Array.isArray(strOrArray)) {\n      this.v = strOrArray;\n    } else if (typeof strOrArray === 'string') {\n      this.v = makeRelativeNormalizedPath(strOrArray, SEP);\n    } else {\n      throw new Error(`Invalid Path argument must be string or array:${strOrArray}`);\n    }\n  }\n\n  toString() {\n    return this.v.join('/');\n  }\n\n  hasParent() {\n    return this.v.length > 0;\n  }\n\n  parent() {\n    if (!this.hasParent()) {\n      throw new Error('Unable to get parent for 0 elem path');\n    }\n\n    const p = this.v.slice();\n    p.pop();\n    return new Path(p);\n  }\n\n  elements() {\n    return this.v.slice();\n  }\n\n  name() {\n    return this.v.slice(-1)[0];\n  }\n\n  contains(other) {\n    let i;\n\n    if (other.length > this.length) {\n      return false;\n    }\n\n    for (i = 0; i < other.length; i += 1) {\n      if (this.v[i] !== other.v[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ancestorOf(other) {\n    return other.contains(this) && other.length !== this.length;\n  }\n\n  descendantOf(other) {\n    return this.contains(other) && other.length !== this.length;\n  }\n\n  commonPrefixPath(other) {\n    const len = this.length > other.length ? other.length : this.length;\n    let i;\n    const ret = [];\n\n    for (i = 0; i < len; i += 1) {\n      if (this.v[i] === other.v[i]) {\n        ret.push(this.v[i]);\n      } else {\n        break;\n      }\n    }\n\n    return new Path(ret);\n  }\n\n  static compare(a, b) {\n    const al = a.length;\n    const bl = b.length;\n\n    if (al < bl) {\n      return -1;\n    }\n\n    if (al > bl) {\n      return 1;\n    }\n\n    const astr = a.toString();\n    const bstr = b.toString();\n    return astr < bstr ? -1 : astr > bstr ? 1 : 0;\n  }\n\n}\n\n['push', 'pop', 'shift', 'unshift', 'splice'].forEach(fn => {\n  Object.defineProperty(Path.prototype, fn, {\n    value() {\n      return this.v[fn](...arguments);\n    }\n\n  });\n});\nObject.defineProperty(Path.prototype, 'length', {\n  enumerable: true,\n\n  get() {\n    return this.v.length;\n  }\n\n});\nmodule.exports = Path;\nPath.tester = {\n  setParserAndSep(p, sep) {\n    parsePath = p;\n    SEP = sep;\n  },\n\n  reset() {\n    parsePath = origParser;\n    SEP = origSep;\n  }\n\n};","map":{"version":3,"sources":["/Users/mdraghi/Development/code/Phase-3/Phase-3-Project/dotify/node_modules/istanbul-lib-report/lib/path.js"],"names":["path","require","parsePath","parse","SEP","sep","origParser","origSep","makeRelativeNormalizedPath","str","parsed","root","dir","file","base","quoted","pos","indexOf","substring","length","RegExp","replace","split","Path","constructor","strOrArray","Array","isArray","v","Error","toString","join","hasParent","parent","p","slice","pop","elements","name","contains","other","i","ancestorOf","descendantOf","commonPrefixPath","len","ret","push","compare","a","b","al","bl","astr","bstr","forEach","fn","Object","defineProperty","prototype","value","enumerable","get","module","exports","tester","setParserAndSep","reset"],"mappings":"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","sourcesContent":["/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst path = require('path');\nlet parsePath = path.parse;\nlet SEP = path.sep;\nconst origParser = parsePath;\nconst origSep = SEP;\n\nfunction makeRelativeNormalizedPath(str, sep) {\n    const parsed = parsePath(str);\n    let root = parsed.root;\n    let dir;\n    let file = parsed.base;\n    let quoted;\n    let pos;\n\n    // handle a weird windows case separately\n    if (sep === '\\\\') {\n        pos = root.indexOf(':\\\\');\n        if (pos >= 0) {\n            root = root.substring(0, pos + 2);\n        }\n    }\n    dir = parsed.dir.substring(root.length);\n\n    if (str === '') {\n        return [];\n    }\n\n    if (sep !== '/') {\n        quoted = new RegExp(sep.replace(/\\W/g, '\\\\$&'), 'g');\n        dir = dir.replace(quoted, '/');\n        file = file.replace(quoted, '/'); // excessively paranoid?\n    }\n\n    if (dir !== '') {\n        dir = `${dir}/${file}`;\n    } else {\n        dir = file;\n    }\n    if (dir.substring(0, 1) === '/') {\n        dir = dir.substring(1);\n    }\n    dir = dir.split(/\\/+/);\n    return dir;\n}\n\nclass Path {\n    constructor(strOrArray) {\n        if (Array.isArray(strOrArray)) {\n            this.v = strOrArray;\n        } else if (typeof strOrArray === 'string') {\n            this.v = makeRelativeNormalizedPath(strOrArray, SEP);\n        } else {\n            throw new Error(\n                `Invalid Path argument must be string or array:${strOrArray}`\n            );\n        }\n    }\n\n    toString() {\n        return this.v.join('/');\n    }\n\n    hasParent() {\n        return this.v.length > 0;\n    }\n\n    parent() {\n        if (!this.hasParent()) {\n            throw new Error('Unable to get parent for 0 elem path');\n        }\n        const p = this.v.slice();\n        p.pop();\n        return new Path(p);\n    }\n\n    elements() {\n        return this.v.slice();\n    }\n\n    name() {\n        return this.v.slice(-1)[0];\n    }\n\n    contains(other) {\n        let i;\n        if (other.length > this.length) {\n            return false;\n        }\n        for (i = 0; i < other.length; i += 1) {\n            if (this.v[i] !== other.v[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    ancestorOf(other) {\n        return other.contains(this) && other.length !== this.length;\n    }\n\n    descendantOf(other) {\n        return this.contains(other) && other.length !== this.length;\n    }\n\n    commonPrefixPath(other) {\n        const len = this.length > other.length ? other.length : this.length;\n        let i;\n        const ret = [];\n\n        for (i = 0; i < len; i += 1) {\n            if (this.v[i] === other.v[i]) {\n                ret.push(this.v[i]);\n            } else {\n                break;\n            }\n        }\n        return new Path(ret);\n    }\n\n    static compare(a, b) {\n        const al = a.length;\n        const bl = b.length;\n\n        if (al < bl) {\n            return -1;\n        }\n\n        if (al > bl) {\n            return 1;\n        }\n\n        const astr = a.toString();\n        const bstr = b.toString();\n        return astr < bstr ? -1 : astr > bstr ? 1 : 0;\n    }\n}\n\n['push', 'pop', 'shift', 'unshift', 'splice'].forEach(fn => {\n    Object.defineProperty(Path.prototype, fn, {\n        value(...args) {\n            return this.v[fn](...args);\n        }\n    });\n});\n\nObject.defineProperty(Path.prototype, 'length', {\n    enumerable: true,\n    get() {\n        return this.v.length;\n    }\n});\n\nmodule.exports = Path;\nPath.tester = {\n    setParserAndSep(p, sep) {\n        parsePath = p;\n        SEP = sep;\n    },\n    reset() {\n        parsePath = origParser;\n        SEP = origSep;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}