{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n/**\n * An object with methods that are called during the traversal of the coverage tree.\n * A visitor has the following methods that are called during tree traversal.\n *\n *   * `onStart(root, state)` - called before traversal begins\n *   * `onSummary(node, state)` - called for every summary node\n *   * `onDetail(node, state)` - called for every detail node\n *   * `onSummaryEnd(node, state)` - called after all children have been visited for\n *      a summary node.\n *   * `onEnd(root, state)` - called after traversal ends\n *\n * @param delegate - a partial visitor that only implements the methods of interest\n *  The visitor object supplies the missing methods as noops. For example, reports\n *  that only need the final coverage summary need implement `onStart` and nothing\n *  else. Reports that use only detailed coverage information need implement `onDetail`\n *  and nothing else.\n * @constructor\n */\n\nclass Visitor {\n  constructor(delegate) {\n    this.delegate = delegate;\n  }\n\n}\n\n['Start', 'End', 'Summary', 'SummaryEnd', 'Detail'].map(k => `on${k}`).forEach(fn => {\n  Object.defineProperty(Visitor.prototype, fn, {\n    writable: true,\n\n    value(node, state) {\n      if (typeof this.delegate[fn] === 'function') {\n        this.delegate[fn](node, state);\n      }\n    }\n\n  });\n});\n\nclass CompositeVisitor extends Visitor {\n  constructor(visitors) {\n    super();\n\n    if (!Array.isArray(visitors)) {\n      visitors = [visitors];\n    }\n\n    this.visitors = visitors.map(v => {\n      if (v instanceof Visitor) {\n        return v;\n      }\n\n      return new Visitor(v);\n    });\n  }\n\n}\n\n['Start', 'Summary', 'SummaryEnd', 'Detail', 'End'].map(k => `on${k}`).forEach(fn => {\n  Object.defineProperty(CompositeVisitor.prototype, fn, {\n    value(node, state) {\n      this.visitors.forEach(v => {\n        v[fn](node, state);\n      });\n    }\n\n  });\n});\n\nclass BaseNode {\n  isRoot() {\n    return !this.getParent();\n  }\n  /**\n   * visit all nodes depth-first from this node down. Note that `onStart`\n   * and `onEnd` are never called on the visitor even if the current\n   * node is the root of the tree.\n   * @param visitor a full visitor that is called during tree traversal\n   * @param state optional state that is passed around\n   */\n\n\n  visit(visitor, state) {\n    if (this.isSummary()) {\n      visitor.onSummary(this, state);\n    } else {\n      visitor.onDetail(this, state);\n    }\n\n    this.getChildren().forEach(child => {\n      child.visit(visitor, state);\n    });\n\n    if (this.isSummary()) {\n      visitor.onSummaryEnd(this, state);\n    }\n  }\n\n}\n/**\n * abstract base class for a coverage tree.\n * @constructor\n */\n\n\nclass BaseTree {\n  constructor(root) {\n    this.root = root;\n  }\n  /**\n   * returns the root node of the tree\n   */\n\n\n  getRoot() {\n    return this.root;\n  }\n  /**\n   * visits the tree depth-first with the supplied partial visitor\n   * @param visitor - a potentially partial visitor\n   * @param state - the state to be passed around during tree traversal\n   */\n\n\n  visit(visitor, state) {\n    if (!(visitor instanceof Visitor)) {\n      visitor = new Visitor(visitor);\n    }\n\n    visitor.onStart(this.getRoot(), state);\n    this.getRoot().visit(visitor, state);\n    visitor.onEnd(this.getRoot(), state);\n  }\n\n}\n\nmodule.exports = {\n  BaseTree,\n  BaseNode,\n  Visitor,\n  CompositeVisitor\n};","map":{"version":3,"sources":["/Users/mdraghi/Development/code/Phase-3/Phase-3-Project/dotify/node_modules/istanbul-lib-report/lib/tree.js"],"names":["Visitor","constructor","delegate","map","k","forEach","fn","Object","defineProperty","prototype","writable","value","node","state","CompositeVisitor","visitors","Array","isArray","v","BaseNode","isRoot","getParent","visit","visitor","isSummary","onSummary","onDetail","getChildren","child","onSummaryEnd","BaseTree","root","getRoot","onStart","onEnd","module","exports"],"mappings":"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","sourcesContent":["/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\n/**\n * An object with methods that are called during the traversal of the coverage tree.\n * A visitor has the following methods that are called during tree traversal.\n *\n *   * `onStart(root, state)` - called before traversal begins\n *   * `onSummary(node, state)` - called for every summary node\n *   * `onDetail(node, state)` - called for every detail node\n *   * `onSummaryEnd(node, state)` - called after all children have been visited for\n *      a summary node.\n *   * `onEnd(root, state)` - called after traversal ends\n *\n * @param delegate - a partial visitor that only implements the methods of interest\n *  The visitor object supplies the missing methods as noops. For example, reports\n *  that only need the final coverage summary need implement `onStart` and nothing\n *  else. Reports that use only detailed coverage information need implement `onDetail`\n *  and nothing else.\n * @constructor\n */\nclass Visitor {\n    constructor(delegate) {\n        this.delegate = delegate;\n    }\n}\n\n['Start', 'End', 'Summary', 'SummaryEnd', 'Detail']\n    .map(k => `on${k}`)\n    .forEach(fn => {\n        Object.defineProperty(Visitor.prototype, fn, {\n            writable: true,\n            value(node, state) {\n                if (typeof this.delegate[fn] === 'function') {\n                    this.delegate[fn](node, state);\n                }\n            }\n        });\n    });\n\nclass CompositeVisitor extends Visitor {\n    constructor(visitors) {\n        super();\n\n        if (!Array.isArray(visitors)) {\n            visitors = [visitors];\n        }\n        this.visitors = visitors.map(v => {\n            if (v instanceof Visitor) {\n                return v;\n            }\n            return new Visitor(v);\n        });\n    }\n}\n\n['Start', 'Summary', 'SummaryEnd', 'Detail', 'End']\n    .map(k => `on${k}`)\n    .forEach(fn => {\n        Object.defineProperty(CompositeVisitor.prototype, fn, {\n            value(node, state) {\n                this.visitors.forEach(v => {\n                    v[fn](node, state);\n                });\n            }\n        });\n    });\n\nclass BaseNode {\n    isRoot() {\n        return !this.getParent();\n    }\n\n    /**\n     * visit all nodes depth-first from this node down. Note that `onStart`\n     * and `onEnd` are never called on the visitor even if the current\n     * node is the root of the tree.\n     * @param visitor a full visitor that is called during tree traversal\n     * @param state optional state that is passed around\n     */\n    visit(visitor, state) {\n        if (this.isSummary()) {\n            visitor.onSummary(this, state);\n        } else {\n            visitor.onDetail(this, state);\n        }\n\n        this.getChildren().forEach(child => {\n            child.visit(visitor, state);\n        });\n\n        if (this.isSummary()) {\n            visitor.onSummaryEnd(this, state);\n        }\n    }\n}\n\n/**\n * abstract base class for a coverage tree.\n * @constructor\n */\nclass BaseTree {\n    constructor(root) {\n        this.root = root;\n    }\n\n    /**\n     * returns the root node of the tree\n     */\n    getRoot() {\n        return this.root;\n    }\n\n    /**\n     * visits the tree depth-first with the supplied partial visitor\n     * @param visitor - a potentially partial visitor\n     * @param state - the state to be passed around during tree traversal\n     */\n    visit(visitor, state) {\n        if (!(visitor instanceof Visitor)) {\n            visitor = new Visitor(visitor);\n        }\n        visitor.onStart(this.getRoot(), state);\n        this.getRoot().visit(visitor, state);\n        visitor.onEnd(this.getRoot(), state);\n    }\n}\n\nmodule.exports = {\n    BaseTree,\n    BaseNode,\n    Visitor,\n    CompositeVisitor\n};\n"]},"metadata":{},"sourceType":"script"}